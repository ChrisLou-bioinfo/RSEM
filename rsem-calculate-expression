#!/usr/bin/env perl

use Getopt::Long qw(:config no_auto_abbrev);
use Pod::Usage;
use File::Basename;
use FindBin;
use lib $FindBin::RealBin;
use rsem_perl_utils qw(runCommand collectResults showVersionInfo getSAMTOOLS hasPolyA);

use Env qw(@PATH);

@PATH = ($FindBin::RealBin, "$FindBin::RealBin/" . getSAMTOOLS(), @PATH);

use strict;
use warnings;



my $paired_end = 0;
my $no_qual = 0;
my $strandedness = "none"; # none, forward, reverse
my $nThreads = 1;
my $is_alignment = 0;
my $faiF = "";
my $appendNames = 0;
my $seed = "NULL";
my $mTime = 0;
my ($time_start, $time_end, $time_alignment, $time_rsem, $time_ci) = (0, 0, 0, 0, 0);

my $bowtie = 0;
my $bowtie_path = "";
my $C = 2;
my $E = 99999999;
my $L = 25;
my $maxHits = 200;
my $chunkMbs = 0;	# 0 = use bowtie default

my $bowtie2 = 0;
my $bowtie2_path = "";
my $bowtie2_mismatch_rate = 0.1;
my $bowtie2_k = 200;
my $bowtie2_sensitivity_level = "sensitive"; # must be one of "very_fast", "fast", "sensitive", "very_sensitive"

my $star = 0;
my $star_path  = '';
my $star_output_genome_bam = 0;

my $hisat2 = 0;
my $hisat2_path = '';


my $tagName = "XM";

my $minL = 1;
my $maxL = 1000;
my $mean = -1;
my $sd = 0;




my $genBamF = 1;  # default is generating transcript bam file
my $genGenomeBamF = 0;
my $sampling = 0;

my $sort_bam_by_coordinate = 0;
my $sort_bam_by_read_name = 0;
my $sort_bam_memory = "1G"; # default as 1G per thread


my $version = 0;
my $quiet = 0;
my $help = 0;


my $status = 0;
my ($refName, $sampleName, $sampleToken, $temp_dir, $stat_dir, $imdName, $statName) = ('') x 7;
my $mate1_list = "";
my $mate2_list = "";
my $inpF = "";

my $gap = 32;

my $alleleS = 0;


my $keep_intermediate_files = 0;










GetOptions("paired-end" => \$paired_end,
		   "no-qualities" => \$no_qual,
		   "strandedness=s" => \$strandedness,
		   "p|num-threads=i" => \$nThreads,
		   "alignments" => \$is_alignment,
		   "fai=s" => \$faiF,
		   "append-names" => \$appendNames,
		   "seed=i" => \$seed,
		   "time" => \$mTime,

		   "bowtie" => \$bowtie,
		   "bowtie-path=s" => \$bowtie_path,
		   "bowtie-n=i" => \$C,
		   "bowtie-e=i" => \$E,
		   "bowtie-l=i" => \$L,
		   "bowtie-m=i" => \$maxHits,
		   "bowtie-chunkmbs=i" => \$chunkMbs,

		   "bowtie2" => \$bowtie2,
		   "bowtie2-path=s" => \$bowtie2_path,
		   "bowtie2-mismatch-rate=f" => \$bowtie2_mismatch_rate,
		   "bowtie2-k=i" => \$bowtie2_k,
		   "bowtie2-sensitivity-level=s" => \$bowtie2_sensitivity_level,

		   "star" => \$star,
		   "star-path=s" => \$star_path,
		   "star-output-genome-bam" => \$star_output_genome_bam,	   

		   "fragment-length-min=i" => \$minL,
		   "fragment-length-max=i" => \$maxL,
		   "fragment-length-mean=f" => \$mean,
		   "fragment-length-sd=f" => \$sd,
		   
		   "no-bam-output" => sub { $genBamF = 0; },
		   "output-genome-bam" => \$genGenomeBamF,
		   "tag=s" => \$tagName,
		   "sort-bam-by-coordinate" => \$sort_bam_by_coordinate,
		   "sort-bam-by-read-name" => \$sort_bam_by_read_name,
		   "sort-bam-memory-per-thread=s" => \$sort_bam_memory,

		   "keep-intermediate-files" => \$keep_intermediate_files,
		   "temporary-folder=s" => \$temp_dir,

		   # help
		   "version" => \$version,
		   "q|quiet" => \$quiet,
		   "h|help" => \$help) or pod2usage(-exitval => 2, -verbose => 2);

pod2usage(-verbose => 2) if ($help == 1);
&showVersionInfo($FindBin::RealBin) if ($version == 1);

#check parameters and options

if ($is_alignment) {
	pod2usage(-msg => "Invalid number of arguments!", -exitval => 2, -verbose => 2) if (scalar(@ARGV) != 3);
	pod2usage(-msg => "--bowtie-path, --bowtie-n, --bowtie-e, --bowtie-m, --phred33-quals, --phred64-quals, --solexa-quals, --bowtie2, --bowtie2-path, --bowtie2-mismatch-rate, --bowtie2-k, --bowtie2-sensitivity-level, --star, --star-path, and --star-output-genome-bam cannot be set if input is SAM/BAM/CRAM format!", -exitval => 2, -verbose => 2) if ($bowtie_path ne "" || $C != 2 || $E != 99999999 || $maxHits != 200 || $phred33 || $phred64 || $solexa || $bowtie2 || $bowtie2_path ne "" || $bowtie2_mismatch_rate != 0.1 || $bowtie2_k != 200 || $bowtie2_sensitivity_level ne "sensitive" || $star || $star_path ne "" || $star_output_genome_bam);
}
else {
	pod2usage(-msg => "Invalid number of arguments!", -exitval => 2, -verbose => 2) if (!$paired_end && scalar(@ARGV) != 3 || $paired_end && scalar(@ARGV) != 4);    
	pod2usage(-msg => "If --no-qualities is set, neither --phred33-quals, --phred64-quals or --solexa-quals can be active!", -exitval => 2, -verbose => 2) if ($no_qual && ($phred33 + $phred64 + $solexa > 0));
	pod2usage(-msg => "Only one of --phred33-quals, --phred64-quals, and --solexa-quals can be active!", -exitval => 2, -verbose => 2) if ($phred33 + $phred64 + $solexa > 1);    
	pod2usage(-msg => "--bowtie2-path, --bowtie2-mismatch-rate, --bowtie2-k and --bowtie2-sensitivity-level cannot be set if bowtie aligner is used!", -exitval => 2, -verbose => 2) if (!$bowtie2 && ($bowtie2_path ne "" || $bowtie2_mismatch_rate != 0.1 || $bowtie2_k != 200 || $bowtie2_sensitivity_level ne "sensitive"));
	pod2usage(-msg => "--bowtie-path, --bowtie-n, --bowtie-e, --bowtie-m cannot be set if bowtie2 aligner is used!", -exitval => 2, -verbose => 2) if ($bowtie2 && ($bowtie_path ne "" || $C != 2 || $E != 99999999 || $maxHits != 200));
	pod2usage(-msg => "Mismatch rate must be within [0, 1]!", -exitval => 2, -verbose => 2) if ($bowtie2 && ($bowtie2_mismatch_rate < 0.0 || $bowtie2_mismatch_rate > 1.0));
	pod2usage(-msg => "Sensitivity level must be one of \"very_fast\", \"fast\", \"sensitive\", and \"very_sensitive\"!", -exitval => 2, -verbose => 2) if ($bowtie2 && (($bowtie2_sensitivity_level ne "very_fast") && ($bowtie2_sensitivity_level ne "fast") && ($bowtie2_sensitivity_level ne "sensitive") && ($bowtie2_sensitivity_level ne "very_sensitive")));
	if ($faiF ne "") { print "Warning: There is no need to set --fai if you ask RSEM to align reads for you.\n" }
}

pod2usage(-msg => "Number of threads should be at least 1!\n", -exitval => 2, -verbose => 2) if ($nThreads < 1);
pod2usage(-msg => "Min fragment length should be at least 1!", -exitval => 2, -verbose => 2) if ($minL < 1);
pod2usage(-msg => "Min fragment length should be smaller or equal to max fragment length!", -exitval => 2, -verbose => 2) if ($minL > $maxL);
pod2usage(-msg => "--output-genome-bam cannot be specified if --no-bam-output is specified!\n", -exitval => 2, -verbose => 2) if ($genGenomeBamF && !$genBamF);
pod2usage(-msg => "The seed for random number generator must be a non-negative 32bit integer!\n", -exitval => 2, -verbose => 2) if (($seed ne "NULL") && ($seed < 0 || $seed > 0xffffffff));




if (scalar(@ARGV) == 3) {
    if ($is_alignment) { $inpF = $ARGV[0]; } 
    else {$mate1_list = $ARGV[0]; }
    $refName = $ARGV[1];
    $sampleName = $ARGV[2];
}
else {
    $mate1_list = $ARGV[0];
    $mate2_list = $ARGV[1];
    $refName = $ARGV[2];
    $sampleName = $ARGV[3];
}

if (((-e "$refName.ta") && !(-e "$refName.gt")) || (!(-e "$refName.ta") && (-e "$refName.gt"))) {
    print "Allele-specific expression related reference files are corrupted!\n";
    exit(-1);
}

$alleleS = (-e "$refName.ta") && (-e "$refName.gt");

pod2usage(-msg => "RSEM reference cannot contain poly(A) tails if you want to use STAR aligner!", -exitval => 2, -verbose => 2) if ($star && (&hasPolyA("$refName.seq")));

if ($genGenomeBamF) {
    open(INPUT, "$refName.ti");
    my $line = <INPUT>; chomp($line);
    close(INPUT);
    my ($M, $type) = split(/ /, $line);
    pod2usage(-msg => "No genome information provided, so genome bam file cannot be generated!\n", -exitval => 2, -verbose => 2) if ($type != 0);
}

my $pos = rindex($sampleName, '/');
if ($pos < 0) { $sampleToken = $sampleName; }
else { $sampleToken = substr($sampleName, $pos + 1); }

if ($temp_dir eq "") { $temp_dir = "$sampleName.temp"; }
$stat_dir = "$sampleName.stat";

if (!(-d $temp_dir) && !mkdir($temp_dir)) { print "Fail to create folder $temp_dir.\n"; exit(-1); }
if (!(-d $stat_dir) && !mkdir($stat_dir)) { print "Fail to create folder $stat_dir.\n"; exit(-1); }

$imdName = "$temp_dir/$sampleToken";
$statName = "$stat_dir/$sampleToken";

my ($mate_minL, $mate_maxL) = (1, $maxL);

if ($bowtie_path ne "") { $bowtie_path .= "/"; }
if ($bowtie2_path ne "") { $bowtie2_path .= "/"; }
if ($star_path ne '') { $star_path .= '/'; }

my $command = "";

if (!$is_alignment) {
	if ($bowtie + $bowtie2 + $star + $hisat2 == 0) { $hisat2 = 1; }

	if ($bowtie) {
		## align reads by bowtie
		$command = $bowtie_path."bowtie";
		if ($no_qual) { $command .= " -f"; }
		else { $command .= " -q"; }

		$command .= " -n $C -e $E -l $L";
		if ($paired_end) { $command .= " -I $minL -X $maxL"; }
		if ($chunkMbs > 0) { $command .= " --chunkmbs $chunkMbs"; }

		if ($strandedness eq "forward") { $command .= " --norc"; }
		elsif ($strandedness eq "reverse") { $command .= " --nofw"; }

		$command .= " -p $nThreads -a -m $maxHits -S";
		if ($quiet) { $command .= " --quiet"; }    

		$command .= " $refName";
		if (!$paried_end) {
			$command .= " $mate1_list"; 
		}
		else {
			$command .= " -1 $mate1_list -2 $mate2_list";
		}

		# pipe to samtools to generate a BAM file
		$command .= " 2> $statName.alignment.log | samtools view -S -b -o $imdName.bam -";
	}
	elsif ($bowtie2) {
		## align reads by bowtie2
		$command = $bowtie2_path."bowtie2";
		if ($no_qual) { $command .= " -f"; }
		else { $command .= " -q"; }

		if ($bowtie2_sensitivity_level eq "very_fast") { $command .= " --very-fast"; }
		elsif ($bowtie2_sensitivity_level eq "fast") { $command .= " --fast"; }
		elsif ($bowtie2_sensitivity_level eq "sensitive") { $command .= " --sensitive"; }
		else { $command .= " --very-sensitive"; }

		$command .= " --mp 1,1 --np 1 --score-min L,0,-$bowtie2_mismatch_rate --rdg 1,1 --rfg 1,1";  

		if ($paired_end) { $command .= " -I $minL -X $maxL --no-mixed --no-discordant"; }

		if ($strandedness eq "forward") { $command .= " --norc"; }
		elsif ($strandedness eq "reverse") { $command .= " --nofw"; }

		$command .= " -p $nThreads -k $bowtie2_k";

		if ($quiet) { $command .= " --quiet"; }    

		$command .= " -x $refName";
		if (!$paired_end) {
			$command .= " -U $mate1_list"; 
		}
		else {
			$command .= " -1 $mate1_list -2 $mate2_list";
		}

		# pipe to samtools to generate a BAM file
		$command .= " 2> $statName.alignment.log | samtools view -S -b -o $imdName.bam -";
	}
	elsif ($star) {
		## align reads by STAR
		my $star_genome_path = dirname($refName);
		$command =  $star_path."STAR" . 
					## ENCODE3 pipeline parameters
					" --genomeDir $star_genome_path" .
					" --outSAMunmapped Within" .
					" --outFilterType BySJout" .
					" --outSAMattributes NH HI AS NM MD" .
					" --outFilterMultimapNmax 20" .
					" --outFilterMismatchNmax 999" .
					" --outFilterMismatchNoverLmax 0.04" .
					" --alignIntronMin 20" .
					" --alignIntronMax 1000000" .
					" --alignMatesGapMax 1000000" .
					" --alignSJoverhangMin 8" .
					" --alignSJDBoverhangMin 1" .
					" --sjdbScore 1" .
					" --runThreadN $nThreads" .
					## different than ENCODE3 pipeline 
					## do not allow using shared memory
					" --genomeLoad NoSharedMemory" .
					## different than ENCODE3 pipeline, which sorts output BAM
					## no need to do it here to save time and memory 
					" --outSAMtype BAM Unsorted" .
					## unlike ENCODE3, we don't output bedGraph files
					" --quantMode TranscriptomeSAM".
					" --outSAMheaderHD \@HD VN:1.4 SO:unsorted".	
					## define output file prefix
					" --outFileNamePrefix $imdName";
		
		if ($mate1_list =~ /.gz$/) { 
			$command .= " --readFilesCommand zcat";
		} elsif ($mate1_list =~ /.bz2$/) { 
			$command .= "--readFilesCommand bzip2 -c";
		}

		if (!$paired_end) {
			$command .= " --readFilesIn $mate1_list";
		} else {
			$command .= " --readFilesIn $mate1_list $mate2_list";
		}
	}
	elsif ($hisat2) {
		## align reads by hisat2
		$command = $hisat2_path."hisat2";
		$command .= " -t -p $nThreads -x $refName";
		$command .= " --rg-id=$sampleName --rg SM:$sampleName --rg LB:$sampleName --rg PL:ILLUMINA --rg PU:$sampleName";
		$command .= " --new-summary --summary-file $statName.alignment.log";
		$command .= " --met-file $imdName.hisat2.met.txt --met 5";
		$command .= " --mp 1,1 --np 1 --score-min L,0,-0.1";
		$command .= " --rdg 1,1 --rfg 1,1 --no-softclip";
		$command .= " -k 10 --max-seeds 10 --secondary";

		if (!$paired_end) {
			if ($strandedness eq "forward") {
				$command .= " --rna-strandness F";
			}
			elsif ($strandedness eq "reverse") {
				$command .= " --rna-strandness R";
			}
			$command .= " -U $mate1_list";
		}
		else {
			$command .= " --no-mixed --no-discordant";	
			if ($strandedness eq "forward") {
				$command .= " --rna-strandness FR";
			}
			elsif ($strandedness eq "reverse") {
				$command .= " --rna-strandness RF";
			}
			$command .= " -1 $mate1_list -2 $mate2_list";
		}

		# pipe to samtools to generate a BAM file
		$command .= " | samtools view -S -b -o $imdName.bam -";

	}

	if ($mTime) { $time_start = time(); }

	&runCommand($command);
	
	if ($mTime) { $time_end = time(); $time_alignment = $time_end - $time_start; }

	$inpF = "$imdName.bam";

	if ($star) {
		my $star_tr_bam = $imdName."Aligned.toTranscriptome.out.bam";
		rename $star_tr_bam, $inpF or die "can't rename $star_tr_bam to $inpF: $!\n";
		rmdir $imdName . "_STARtmp/";
		my $star_genome_bam = $imdName."Aligned.out.bam";
		my $rsem_star_genome_bam = $sampleName.".STAR.genome.bam";
		if ( $star_output_genome_bam ) {
			rename $star_genome_bam, $rsem_star_genome_bam or die 
		    "can't move $star_genome_bam to $rsem_star_genome_bam: $!\n";
		} else {
			unlink $star_genome_bam or die "can't remove $star_genome_bam: $!\n";
		}
	}
}

if ( $sort_bam_by_read_name ) {
	my $sorted_bam = "$imdName.sorted.bam";
	$command = "samtools sort -n -@ $nThreads -m $sort_bam_memory -o $sorted_bam $inpF";
	&runCommand($command);
	if (!$is_alignment) {
		$command = "rm -f $inpF";
		&runCommand($command);
	}
	$inpF = $sorted_bam;
}

if ($mTime) { $time_start = time(); }

$command = "rsem-parse-alignments $refName $imdName $statName $inpF $read_type";
if ($faiF ne "") { $command .= " -t $faiF"; }
if ($tagName ne "") { $command .= " -tag $tagName"; }
if ($quiet) { $command .= " -q"; }

&runCommand($command);

$command = "rsem-build-read-index $gap"; 
if ($read_type == 0) { $command .= " 0 $quiet $imdName\_alignable.fa"; }
elsif ($read_type == 1) { $command .= " 1 $quiet $imdName\_alignable.fq"; }
elsif ($read_type == 2) { $command .= " 0 $quiet $imdName\_alignable_1.fa $imdName\_alignable_2.fa"; }
elsif ($read_type == 3) { $command .= " 1 $quiet $imdName\_alignable_1.fq $imdName\_alignable_2.fq"; }
else { print "Impossible! read_type is not in [1,2,3,4]!\n"; exit(-1); }
&runCommand($command);

my $doesOpen = open(OUTPUT, ">$imdName.mparams");
if ($doesOpen == 0) { print "Cannot generate $imdName.mparams!\n"; exit(-1); }
print OUTPUT "$minL $maxL\n";
print OUTPUT "$probF\n";
print OUTPUT "$estRSPD\n";
print OUTPUT "$B\n";
print OUTPUT "$mate_minL $mate_maxL\n";
print OUTPUT "$mean $sd\n";
print OUTPUT "$L\n";
close(OUTPUT);  

my @seeds = ();
if ($seed ne "NULL") { 
    srand($seed); 
    for (my $i = 0; $i < 3; $i++) {
	push(@seeds, int(rand(1 << 32))); 
    }
}

$command = "rsem-run-em $refName $read_type $sampleName $imdName $statName -p $nThreads";
if ($genBamF) { 
    $command .= " -b $inpF";
    if ($faiF ne "") { $command .= " 1 $faiF"; }
    else { $command .= " 0"; }
    if ($sampling) { $command .= " --sampling"; }
    if ($seed ne "NULL") { $command .= " --seed $seeds[0]"; }
}
if ($calcPME || $calcCI) { $command .= " --gibbs-out"; }
if ($appendNames) { $command .= " --append-names"; }
if ($quiet) { $command .= " -q"; }

&runCommand($command);

if ($alleleS) {
    &collectResults("allele", "$imdName.allele_res", "$sampleName.alleles.results"); # allele level
    &collectResults("isoform", "$imdName.iso_res", "$sampleName.isoforms.results"); # isoform level
    &collectResults("gene", "$imdName.gene_res", "$sampleName.genes.results"); # gene level
} 
else {
    &collectResults("isoform", "$imdName.iso_res", "$sampleName.isoforms.results"); # isoform level
    &collectResults("gene", "$imdName.gene_res", "$sampleName.genes.results"); # gene level
}

if ($genBamF) {
    if ($genGenomeBamF) {
	$command = "rsem-tbam2gbam $refName $sampleName.transcript.bam $sampleName.genome.bam";
	&runCommand($command);
    }
    
    if ($sort_bam_by_coordinate) {
	$command = "samtools sort -@ $nThreads -m $sort_bam_memory -o $sampleName.transcript.sorted.bam $sampleName.transcript.bam";
	&runCommand($command);
	$command = "samtools index $sampleName.transcript.sorted.bam";
	&runCommand($command);

	if ($genGenomeBamF) {
	    $command = "samtools sort -@ $nThreads -m $sort_bam_memory -o $sampleName.genome.sorted.bam $sampleName.genome.bam";
	    &runCommand($command);
	    $command = "samtools index $sampleName.genome.sorted.bam";
	    &runCommand($command);
	}
    }
}

if ($mTime) { $time_end = time(); $time_rsem = $time_end - $time_start; }

if (!$keep_intermediate_files) {
    &runCommand("rm -rf $temp_dir", "Fail to delete the temporary folder!");
}

if ($mTime) { $time_end = time(); }

if ($mTime) { 
    open(OUTPUT, ">$sampleName.time");
    print OUTPUT "Aligning reads: $time_alignment s.\n";
    print OUTPUT "Estimating expression levels: $time_rsem s.\n";
    close(OUTPUT);
}

__END__

=head1 NAME

rsem-calculate-expression - Estimate gene and isoform expression from RNA-Seq data.

=head1 SYNOPSIS

 rsem-calculate-expression [options] upstream_read_file(s) reference_name sample_name 
 rsem-calculate-expression [options] --paired-end upstream_read_file(s) downstream_read_file(s) reference_name sample_name 
 rsem-calculate-expression [options] --alignments [--paired-end] input reference_name sample_name

=head1 ARGUMENTS

=over

=item B<upstream_read_files(s)>

Comma-separated list of files containing single-end reads or upstream reads for paired-end data.  By default, these files are assumed to be in FASTQ format.  If the --no-qualities option is specified, then FASTA format is expected.

=item B<downstream_read_file(s)>

Comma-separated list of files containing downstream reads which are paired with the upstream reads.  By default, these files are assumed to be in FASTQ format.  If the --no-qualities option is specified, then FASTA format is expected.

=item B<input>

SAM/BAM/CRAM formatted input file.  If "-" is specified for the filename, the input is instead assumed to come from standard input. RSEM requires all alignments of the same read group together. For paired-end reads, RSEM also requires the two mates of any alignment be adjacent. In addition, RSEM does not allow the SEQ and QUAL fields to be empty. See Description section for how to make input file obey RSEM's requirements.

=item B<reference_name>                        

The name of the reference used.  The user must have run 'rsem-prepare-reference' with this reference_name before running this program.

=item B<sample_name>

The name of the sample analyzed. All output files are prefixed by this name (e.g., sample_name.genes.results)

=back

=head1 BASIC OPTIONS

=over

=item B<--paired-end>

Input reads are paired-end reads. (Default: off)

=item B<--no-qualities>

Input reads do not contain quality scores. (Default: off)

=item B<--strandedness> <none|forward|reverse>

This option defines the strandedness of the RNA-Seq reads. It recognizes three values: 'none', 'forward', and 'reverse'. 'none' refers to non-strand-specific protocols. 'forward' means all (upstream) reads are derived from the forward strand. 'reverse' means all (upstream) reads are derived from the reverse strand. If 'forward'/'reverse' is set, the '--norc'/'--nofw' Bowtie/Bowtie 2 option will also be enabled to avoid aligning reads to the opposite strand. For Illumina TruSeq Stranded protocols, please use 'reverse'. (Default: 'none')

=item B<-p/--num-threads> <int>

Number of threads to use. Both Bowtie/Bowtie2, expression estimation and 'samtools sort' will use this many threads. (Default: 1)

=item B<--alignments>

Input file contains alignments in SAM/BAM/CRAM format. The exact file format will be determined automatically. (Default: off)

=item B<--fai> <file>

If the header section of input alignment file does not contain reference sequence information, this option should be turned on. <file> is a FAI format file containing each reference sequence's name and length. Please refer to the SAM official website for the details of FAI format. (Default: off)

=item B<--bowtie> 

Use Bowtie to align reads. (Default: off)

=item B<--bowtie2>

Use Bowtie 2 to align reads. For Bowtie 2, we use options '--sensitive --mp 1,1 --np 1 --score-min L,0,-0.1 --rdg 1,1 --rfg 1,1' by default. The last parameter of '--score-min', '-0.1', is the negative of maximum mismatch rate, which can be set by option '--bowtie2-mismatch-rate'. If reads are paired-end, we additionally use options '--no-mixed' and '--no-discordant'. (Default: off)

=item B<--star>

Use STAR to align reads. Alignment parameters are from ENCODE3's STAR-RSEM pipeline. To save computational time and memory resources, STAR's Output BAM file is unsorted. It is stored in RSEM's temporary directory with name as 'sample_name.bam'. Each STAR job will have its own private copy of the genome in memory. (Default: off) 

=item B<--hisat2>

Use HISAT2 to align reads. (Default: on)

=item B<--append-names>

If gene_name/transcript_name is available, append it to the end of gene_id/transcript_id (separated by '_') in files 'sample_name.isoforms.results' and 'sample_name.genes.results'. (Default: off)

=item B<--seed> <uint32>

Set the seed for the random number generators used in calculating posterior mean estimates and credibility intervals. The seed must be a non-negative 32 bit integer. (Default: off)

=item B<-q/--quiet>

Suppress the output of logging information. (Default: off)

=item B<-h/--help>

Show help information.

=item B<--version>

Show version information.

=back

=head1 OUTPUT OPTIONS

=over

=item B<--sort-bam-by-read-name>

Sort BAM file aligned under transcript coordidate by read name. Setting this option on will produce deterministic maximum likelihood estimations from independent runs. Note that sorting will take long time and lots of memory. (Default: off)

=item B<--no-bam-output>

Do not output any BAM file. (Default: off)

=item B<--output-genome-bam>

Generate a BAM file, 'sample_name.genome.bam', with alignments mapped to genomic coordinates and annotated with their posterior probabilities. In addition, RSEM will call samtools (included in RSEM package) to sort and index the bam file. 'sample_name.genome.sorted.bam' and 'sample_name.genome.sorted.bam.bai' will be generated. (Default: off)

=item B<--sort-bam-by-coordinate>

Sort RSEM generated transcript and genome BAM files by coordinates and build associated indices. (Default: off)  

=item B<--sort-bam-memory-per-thread> <string>

Set the maximum memory per thread that can be used by 'samtools sort'. <string> represents the memory and accepts suffices 'K/M/G'. RSEM will pass <string> to the '-m' option of 'samtools sort'. Note that the default used here is different from the default used by samtools. (Default: 1G)

=back

=head1 ALIGNER OPTIONS

=over

=item B<--bowtie-path> <path>

The path to the Bowtie executables. (Default: the path to the Bowtie executables is assumed to be in the user's PATH environment variable)

=item B<--bowtie-n> <int>

(Bowtie parameter) max # of mismatches in the seed. (Range: 0-3, Default: 2)

=item B<--bowtie-e> <int>

(Bowtie parameter) max sum of mismatch quality scores across the alignment. (Default: 99999999)

=item B<--seed-length> <int>

(Bowtie parameter) seed length used by the read aligner. (Default: 25)

=item B<--bowtie-m> <int>

(Bowtie parameter) suppress all alignments for a read if > <int> valid alignments exist. (Default: 200)

=item B<--bowtie-chunkmbs> <int>

(Bowtie parameter) memory allocated for best first alignment calculation (Default: 0 - use Bowtie's default)

=item B<--bowtie2-path> <path>

(Bowtie 2 parameter) The path to the Bowtie 2 executables. (Default: the path to the Bowtie 2 executables is assumed to be in the user's PATH environment variable)

=item B<--bowtie2-mismatch-rate> <double>

(Bowtie 2 parameter) The maximum mismatch rate allowed. (Default: 0.1)

=item B<--bowtie2-k> <int>

(Bowtie 2 parameter) Find up to <int> alignments per read. (Default: 200)

=item B<--bowtie2-sensitivity-level> <string>

(Bowtie 2 parameter) Set Bowtie 2's preset options in --end-to-end mode. This option controls how hard Bowtie 2 tries to find alignments. <string> must be one of "very_fast", "fast", "sensitive" and "very_sensitive". The four candidates correspond to Bowtie 2's "--very-fast", "--fast", "--sensitive" and "--very-sensitive" options. (Default: "sensitive" - use Bowtie 2's default)

=item B<--star-path> <path>

The path to STAR's executable. (Default: the path to STAR executable is assumed to be in user's PATH environment variable)

=item B<--star-gzipped-read-file>

(STAR parameter) Input read file(s) is compressed by gzip. (Default: off)

=item B<--star-bzipped-read-file>

(STAR parameter) Input read file(s) is compressed by bzip2. (Default: off)

=item B<--star-output-genome-bam>

(STAR parameter) Save the BAM file from STAR alignment under genomic coordinate to 'sample_name.STAR.genome.bam'. This file is NOT sorted by genomic coordinate. In this file, according to STAR's manual, 'paired ends of an alignment are always adjacent, and multiple alignments of a read are adjacent as well'. (Default: off)

=item B<--hisat2-path> <path>

(HISAT 2 parameter) The path to the HISAT 2 executables. (Default: the path to the Bowtie 2 executables is assumed to be in the user's PATH environment variable)

=back

=head1 ADVANCED OPTIONS

=over

=item B<--tag> <string>

The name of the optional field used in the SAM input for identifying a read with too many valid alignments. The field should have the format <tagName>:i:<value>, where a <value> bigger than 0 indicates a read with too many alignments. (Default: "")

=item B<--fragment-length-min> <int>

Minimum read/insert length allowed. This is also the value for the Bowtie/Bowtie2 -I option. (Default: 1)

=item B<--fragment-length-max> <int>

Maximum read/insert length allowed. This is also the value for the Bowtie/Bowtie 2 -X option. (Default: 1000)

=item B<--fragment-length-mean> <double>

(single-end data only) The mean of the fragment length distribution, which is assumed to be a Gaussian. (Default: -1, which disables use of the fragment length distribution)

=item B<--fragment-length-sd> <double>

(single-end data only) The standard deviation of the fragment length distribution, which is assumed to be a Gaussian.  (Default: 0, which assumes that all fragments are of the same length, given by the rounded value of B<--fragment-length-mean>)

=item B<--keep-intermediate-files>

Keep temporary files generated by RSEM.  RSEM creates a temporary directory, 'sample_name.temp', into which it puts all intermediate output files. If this directory already exists, RSEM overwrites all files generated by previous RSEM runs inside of it. By default, after RSEM finishes, the temporary directory is deleted.  Set this option to prevent the deletion of this directory and the intermediate files inside of it. (Default: off)

=item B<--temporary-folder> <string>

Set where to put the temporary files generated by RSEM. If the folder specified does not exist, RSEM will try to create it. (Default: sample_name.temp)

=item B<--time>

Output time consumed by each step of RSEM to 'sample_name.time'. (Default: off)

=back

=head1 DESCRIPTION

In its default mode, this program aligns input reads against a reference transcriptome with Bowtie and calculates expression values using the alignments.  RSEM assumes the data are single-end reads with quality scores, unless the '--paired-end' or '--no-qualities' options are specified. Alternatively, users can use STAR to align reads using the '--star' option. RSEM has provided options in 'rsem-prepare-reference' to prepare STAR's genome indices. Users may use an alternative aligner by specifying '--alignments', and providing an alignment file in SAM/BAM/CRAM format. However, users should make sure that they align against the indices generated by 'rsem-prepare-reference' and the alignment file satisfies the requirements mentioned in ARGUMENTS section. 

One simple way to make the alignment file satisfying RSEM's requirements is to use the 'convert-sam-for-rsem' script. This script accepts SAM/BAM/CRAM files as input and outputs a BAM file. For example, type the following command to convert a SAM file, 'input.sam', to a ready-for-use BAM file, 'input_for_rsem.bam':

  convert-sam-for-rsem input.sam input_for_rsem  

For details, please refer to 'convert-sam-for-rsem's documentation page.

=head1 NOTES

1. Users must run 'rsem-prepare-reference' with the appropriate reference before using this program.

2. For single-end data, it is strongly recommended that the user provide the fragment length distribution parameters (--fragment-length-mean and --fragment-length-sd).  For paired-end data, RSEM will automatically learn a fragment length distribution from the data.

3. Some aligner parameters have default values different from their original settings.
 
4. With the '--calc-pme' option, posterior mean estimates will be calculated in addition to maximum likelihood estimates.

5. With the '--calc-ci' option, 95% credibility intervals and posterior mean estimates will be calculated in addition to maximum likelihood estimates.

6. The temporary directory and all intermediate files will be removed when RSEM finishes unless '--keep-intermediate-files' is specified.

With the '--run-pRSEM' option and associated options (see section 'PRIOR-ENHANCED RSEM OPTIONS' above for details), prior-enhanced RSEM will be running. Prior parameters will be learned from supplied external data set(s) and assigned as initial pseudo-counts for isoforms in the corresponding partition for Gibbs sampling.

=head1 OUTPUT

=over

=item B<sample_name.isoforms.results> 

File containing isoform level expression estimates. The first line
contains column names separated by the tab character. The format of
each line in the rest of this file is:

transcript_id gene_id length effective_length expected_count TPM FPKM IsoPct [posterior_mean_count posterior_standard_deviation_of_count pme_TPM pme_FPKM IsoPct_from_pme_TPM TPM_ci_lower_bound TPM_ci_upper_bound TPM_coefficient_of_quartile_variation FPKM_ci_lower_bound FPKM_ci_upper_bound FPKM_coefficient_of_quartile_variation]

Fields are separated by the tab character. Fields within "[]" are
optional. They will not be presented if neither '--calc-pme' nor
'--calc-ci' is set.

'transcript_id' is the transcript name of this transcript. 'gene_id'
is the gene name of the gene which this transcript belongs to (denote
this gene as its parent gene). If no gene information is provided,
'gene_id' and 'transcript_id' are the same.

'length' is this transcript's sequence length (poly(A) tail is not
counted). 'effective_length' counts only the positions that can
generate a valid fragment. If no poly(A) tail is added,
'effective_length' is equal to transcript length - mean fragment
length + 1. If one transcript's effective length is less than 1, this
transcript's both effective length and abundance estimates are set to
0.

'expected_count' is the sum of the posterior probability of each read
comes from this transcript over all reads. Because 1) each read
aligning to this transcript has a probability of being generated from
background noise; 2) RSEM may filter some alignable low quality reads,
the sum of expected counts for all transcript are generally less than
the total number of reads aligned.

'TPM' stands for Transcripts Per Million. It is a relative measure of
transcript abundance. The sum of all transcripts' TPM is 1
million. 'FPKM' stands for Fragments Per Kilobase of transcript per
Million mapped reads. It is another relative measure of transcript
abundance. If we define l_bar be the mean transcript length in a
sample, which can be calculated as

l_bar = \sum_i TPM_i / 10^6 * effective_length_i (i goes through every transcript), 

the following equation is hold:

FPKM_i = 10^3 / l_bar * TPM_i.

We can see that the sum of FPKM is not a constant across samples.

'IsoPct' stands for isoform percentage. It is the percentage of this
transcript's abandunce over its parent gene's abandunce. If its parent
gene has only one isoform or the gene information is not provided,
this field will be set to 100.

'posterior_mean_count', 'pme_TPM', 'pme_FPKM' are posterior mean
estimates calculated by RSEM's Gibbs
sampler. 'posterior_standard_deviation_of_count' is the posterior
standard deviation of counts. 'IsoPct_from_pme_TPM' is the isoform
percentage calculated from 'pme_TPM' values.

'TPM_ci_lower_bound', 'TPM_ci_upper_bound', 'FPKM_ci_lower_bound' and
'FPKM_ci_upper_bound' are lower(l) and upper(u) bounds of 95%
credibility intervals for TPM and FPKM values. The bounds are
inclusive (i.e. [l, u]). 

'TPM_coefficient_of_quartile_variation' and
'FPKM_coefficient_of_quartile_variation' are coefficients of quartile
variation (CQV) for TPM and FPKM values. CQV is a robust way of
measuring the ratio between the standard deviation and the mean. It is
defined as

CQV := (Q3 - Q1) / (Q3 + Q1),

where Q1 and Q3 are the first and third quartiles. 

=item B<sample_name.genes.results>

File containing gene level expression estimates. The first line
contains column names separated by the tab character. The format of
each line in the rest of this file is:

gene_id transcript_id(s) length effective_length expected_count TPM FPKM [posterior_mean_count posterior_standard_deviation_of_count pme_TPM pme_FPKM TPM_ci_lower_bound TPM_ci_upper_bound TPM_coefficient_of_quartile_variation FPKM_ci_lower_bound FPKM_ci_upper_bound FPKM_coefficient_of_quartile_variation]

Fields are separated by the tab character. Fields within "[]" are
optional. They will not be presented if neither '--calc-pme' nor
'--calc-ci' is set.

'transcript_id(s)' is a comma-separated list of transcript_ids
belonging to this gene. If no gene information is provided, 'gene_id'
and 'transcript_id(s)' are identical (the 'transcript_id').

A gene's 'length' and 'effective_length' are
defined as the weighted average of its transcripts' lengths and
effective lengths (weighted by 'IsoPct'). A gene's abundance estimates
are just the sum of its transcripts' abundance estimates.

=item B<sample_name.alleles.results>

Only generated when the RSEM references are built with allele-specific
transcripts.

This file contains allele level expression estimates for
allele-specific expression calculation. The first line
contains column names separated by the tab character. The format of
each line in the rest of this file is:

allele_id transcript_id gene_id length effective_length expected_count TPM FPKM AlleleIsoPct AlleleGenePct [posterior_mean_count posterior_standard_deviation_of_count pme_TPM pme_FPKM AlleleIsoPct_from_pme_TPM AlleleGenePct_from_pme_TPM TPM_ci_lower_bound TPM_ci_upper_bound TPM_coefficient_of_quartile_variation FPKM_ci_lower_bound FPKM_ci_upper_bound FPKM_coefficient_of_quartile_variation]

Fields are separated by the tab character. Fields within "[]" are
optional. They will not be presented if neither '--calc-pme' nor
'--calc-ci' is set.

'allele_id' is the allele-specific name of this allele-specific transcript.

'AlleleIsoPct' stands for allele-specific percentage on isoform
level. It is the percentage of this allele-specific transcript's
abundance over its parent transcript's abundance. If its parent
transcript has only one allele variant form, this field will be set to
100.

'AlleleGenePct' stands for allele-specific percentage on gene
level. It is the percentage of this allele-specific transcript's
abundance over its parent gene's abundance.

'AlleleIsoPct_from_pme_TPM' and 'AlleleGenePct_from_pme_TPM' have
similar meanings. They are calculated based on posterior mean
estimates.

Please note that if this file is present, the fields 'length' and
'effective_length' in 'sample_name.isoforms.results' should be
interpreted similarly as the corresponding definitions in
'sample_name.genes.results'.

=item B<sample_name.transcript.bam> 

Only generated when --no-bam-output is not specified.

'sample_name.transcript.bam' is a BAM-formatted file of read
alignments in transcript coordinates. The MAPQ field of each alignment
is set to min(100, floor(-10 * log10(1.0 - w) + 0.5)), where w is the
posterior probability of that alignment being the true mapping of a
read.  In addition, RSEM pads a new tag ZW:f:value, where value is a
single precision floating number representing the posterior
probability. Because this file contains all alignment lines produced
by bowtie or user-specified aligners, it can also be used as a
replacement of the aligner generated BAM/SAM file.

=item B<sample_name.transcript.sorted.bam and sample_name.transcript.sorted.bam.bai>

Only generated when --no-bam-output is not specified and --sort-bam-by-coordinate is specified.

'sample_name.transcript.sorted.bam' and
'sample_name.transcript.sorted.bam.bai' are the sorted BAM file and
indices generated by samtools (included in RSEM package).

=item B<sample_name.genome.bam>

Only generated when --no-bam-output is not specified and --output-genome-bam is specified.

'sample_name.genome.bam' is a BAM-formatted file of read alignments in
genomic coordinates. Alignments of reads that have identical genomic
coordinates (i.e., alignments to different isoforms that share the
same genomic region) are collapsed into one alignment.  The MAPQ field
of each alignment is set to min(100, floor(-10 * log10(1.0 - w) +
0.5)), where w is the posterior probability of that alignment being
the true mapping of a read.  In addition, RSEM pads a new tag
ZW:f:value, where value is a single precision floating number
representing the posterior probability. If an alignment is spliced, a
XS:A:value tag is also added, where value is either '+' or '-'
indicating the strand of the transcript it aligns to.

=item B<sample_name.genome.sorted.bam and sample_name.genome.sorted.bam.bai>

Only generated when --no-bam-output is not specified, and --sort-bam-by-coordinate and --output-genome-bam are specified.

'sample_name.genome.sorted.bam' and 'sample_name.genome.sorted.bam.bai' are the
sorted BAM file and indices generated by samtools (included in RSEM package).

=item B<sample_name.time>

Only generated when --time is specified.

It contains time (in seconds) consumed by aligning reads, estimating expression levels and calculating credibility intervals.

=item B<sample_name.stat>

This is a folder instead of a file. All model related statistics are stored in this folder. Use 'rsem-plot-model' can generate plots using this folder. 

'sample_name.stat/sample_name.cnt' contains alignment statistics. The format and meanings of each field are described in 'cnt_file_description.txt' under RSEM directory.

'sample_name.stat/sample_name.model' stores RNA-Seq model parameters learned from the data. The format and meanings of each filed of this file are described in 'model_file_description.txt' under RSEM directory.

=back

=head1 EXAMPLES

Assume the path to the bowtie executables is in the user's PATH environment variable. Reference files are under '/ref' with name 'mouse_125'. 

1) '/data/mmliver.fq', single-end reads with quality scores. Quality scores are encoded as for 'GA pipeline version >= 1.3'. We want to use 8 threads and generate a genome BAM file. In addition, we want to append gene/transcript names to the result files:

 rsem-calculate-expression --phred64-quals \
                           -p 8 \
                           --append-names \
                           --output-genome-bam \
                           /data/mmliver.fq \
                           /ref/mouse_125 \
                           mmliver_single_quals

2) '/data/mmliver_1.fq' and '/data/mmliver_2.fq', stranded paired-end reads with quality scores. Suppose the library is prepared using TruSeq Stranded Kit, which means the first mate should map to the reverse strand. Quality scores are in SANGER format. We want to use 8 threads and do not generate a genome BAM file:

 rsem-calculate-expression -p 8 \
                           --paired-end \
                           --strandedness reverse \
                           /data/mmliver_1.fq \
                           /data/mmliver_2.fq \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals

3) '/data/mmliver.fa', single-end reads without quality scores. We want to use 8 threads:

 rsem-calculate-expression -p 8 \
                           --no-qualities \
                           /data/mmliver.fa \
                           /ref/mouse_125 \
                           mmliver_single_without_quals

4) Data are the same as 1). This time we assume the bowtie executables are under '/sw/bowtie'. We want to take a fragment length distribution into consideration. We set the fragment length mean to 150 and the standard deviation to 35. In addition to a BAM file, we also want to generate credibility intervals. We allow RSEM to use 1GB of memory for CI calculation:

 rsem-calculate-expression --bowtie-path /sw/bowtie \
                           --phred64-quals \
                           --fragment-length-mean 150.0 \
                           --fragment-length-sd 35.0 \
                           -p 8 \
                           --output-genome-bam \
                           --calc-ci \
                           --ci-memory 1024 \
                           /data/mmliver.fq \
                           /ref/mouse_125 \
                           mmliver_single_quals

5) '/data/mmliver_paired_end_quals.bam', BAM-formatted alignments for paired-end reads with quality scores. We want to use 8 threads:

 rsem-calculate-expression --paired-end \
                           --alignments \
                           -p 8 \
                           /data/mmliver_paired_end_quals.bam \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals

6) '/data/mmliver_1.fq.gz' and '/data/mmliver_2.fq.gz', paired-end reads with quality scores and read files are compressed by gzip. We want to use STAR to aligned reads and assume STAR executable is '/sw/STAR'. Suppose we want to use 8 threads and do not generate a genome BAM file:

 rsem-calculate-expression --paired-end \
                           --star \
                           --star-path /sw/STAR \
                           --gzipped-read-file \
                           --paired-end \
                           -p 8 \
                           /data/mmliver_1.fq.gz \
                           /data/mmliver_2.fq.gz \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals


7) In the above example, suppose we want to run prior-enhanced RSEM instead. Assuming we want to learn priors from a ChIP-seq peak file '/data/mmlive.narrowPeak.gz':

 rsem-calculate-expression --star \
                           --star-path /sw/STAR \
                           --gzipped-read-file \
                           --paired-end \
                           --calc-pme \
                           --run-pRSEM \
                           --chipseq-peak-file /data/mmliver.narrowPeak.gz \
                           -p 8 \
                           /data/mmliver_1.fq.gz \
                           /data/mmliver_2.fq.gz \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals

8) Similar to the example in 7), suppose we want to use the partition model 'pk_lm2nopk' (partitioning isoforms by Pol II TSS peak first and then partitioning 'no TSS peak' isoforms into two bins by a linear regression model), and we want to partition isoforms by RNA Pol II's ChIP-seq read files '/data/mmliver_PolIIRep1.fq.gz' and '/data/mmliver_PolIIRep2.fq.gz', and the control ChIP-seq read files '/data/mmliver_ChIPseqCtrl.fq.gz'. Also, assuming Bowtie's executables are under '/sw/bowtie/': 

 rsem-calculate-expression --star \
                           --star-path /sw/STAR \
                           --gzipped-read-file \
                           --paired-end \
                           --calc-pme \
                           --run-pRSEM \
                           --chipseq-target-read-files /data/mmliver_PolIIRep1.fq.gz,/data/mmliver_PolIIRep2.fq.gz \
                           --chipseq-control-read-files /data/mmliver_ChIPseqCtrl.fq.gz \
                           --partition-model pk_lm2nopk \
                           --bowtie-path /sw/bowtie \
                           -p 8 \
                           /data/mmliver_1.fq.gz \
                           /data/mmliver_2.fq.gz \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals

9) Similar to the example in 8), suppose we want to derive prior from four histone modification ChIP-seq read data sets: '/data/H3K27Ac.fastq.gz', '/data/H3K4me1.fastq.gz', '/data/H3K4me2.fastq.gz', and '/data/H3K4me3.fastq.gz'. Also, assuming Bowtie's executables are under '/sw/bowtie/': 

 rsem-calculate-expression --star \
                           --star-path /sw/STAR \
                           --gzipped-read-file \
                           --paired-end \
                           --calc-pme \
                           --run-pRSEM \
                           --partition-model cmb_lgt \
                           --chipseq-read-files-multi-targets /data/H3K27Ac.fastq.gz,/data/H3K4me1.fastq.gz,/data/H3K4me2.fastq.gz,/data/H3K4me3.fastq.gz \
                           --bowtie-path /sw/bowtie \
                           -p 8 \
                           /data/mmliver_1.fq.gz \
                           /data/mmliver_2.fq.gz \
                           /ref/mouse_125 \
                           mmliver_paired_end_quals

=cut
